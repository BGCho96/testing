# DAY3 자료구조  


type name| 비고 | varName=
--------|--------|-----
스택/큐 | LIFO, FIFO|<pre>list()/[]<code>
튜플 | 수정불가 list,값에 대한 조회만 가능|<pre>tuple()/(,)<code>
set | 중복요소가 없는 집합 생성,  discard()-존재하지 않는 요소 삭제 가능,  remove()-제거 대상이 없으면 오류|<pre>set()/{}<code>
dictionary | set와 유사. : 를 통해 해시처럼 꼬리를 달고 있다. key는 중복 불가능이란 점에서 set와 같이 {} 선언은 참으로 적절할지도|dict()


collections
==========
deque
-----------
순환리스트. 주소값의 연속 보다는 하나의 요소가 다음 요소를 가리키는....뭔가 연결관계가 우선시 되는 느낌  
rotate나 좌우 append, pop 기능이 있어서 조금 더 편하다.  

OrderdDict()
-----------
옛날 옛적엔 딕셔너리 입력 순서!=실제 리스트 구조 였단다
그래서 key 등이 지맘대로 정렬 안되게 입력 순서=key 순서가 되게끔 보장해주는 메소드

defaultdict()
----------------
value값에 대하여 별도의 입력이 없을 경우 디폴트 값 지정  
list같은 type을 지정해 주거나 별도 지정 없이 디폴트 값으로 call 가능하게 해준다  

namedtuple()  
--------------
튜플 선언할 때 튜플의 이름, 내부 형태를 지정해준다. 아직 좀 헷갈림  
call이름=namedtuple(튜플이름, 튜플생김새(키워드))  
변수이름=call이름(입력)  
솔직히 잘 모르겠음. 걍 익숙한 tuple이나 list 메소드를 좀 더 정교하게 짜는게 가독성 높을거 같음


hotkey
===========
Jupyter :  
<kbd>a</kbd> 윗줄에 셀 생성  
<kbd>b</kbd> 아랫줄에 셀 생성

Pythonic?
=========
대충 반복문 한줄로 줄여쓸수 있다 이런거  
이하 서술 내용은 필수라기 보다는 모르면 남의 코드 읽기 난감한 그런 내용들  
map : 함수의 입력값 등 찢어서 사용. 함수 이름에 lambda 쓰이는 등 가독성 하락 주의요망  
reduce : map의 역할을 여러개가 아닌 하나의 리스트에 대해 실행. 크기가 큰 리스트 연산에 사용. 가독성 ㅆㅎㅌㅊ  
iter() : 리스트의 주소 꽂아주기. next 등의 기능 사용할수 있게 됨
genernator : yield 사용하여 주소정보?만 할당해 주는듯. 실제 값이 call  되기 전까지 용량이랑 속도 개선이 있어서 크기가 큰 list에 적절할듯.


aug
-------
keyword aug : 순서 말고 키워드를 참조하여 함수에 값 전달  
default aug : 디폴트 설정해줘서 해당 값이 전달 안되면 디폴트로 픽스
asterisk : 변수의 개수가 안정해진 경우 쭉쭉 받아준다 *aug  
**aug : 가변인자를 키워드랑 매칭해서 딕셔너리 형태로 전달해준다  
위 모든 것은 : @(kw,*aug,**aug)의 순서를 지켜야 한다. 안그럼 컴이 어느게 어느건지 꼬이고 헷갈려서 오류남

쓰면서 들은 노래 : Tangled Up (Lokee Remix)
